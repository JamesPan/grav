---
title: '魔改 Grafana 我学到的事'
published: false
taxonomy:
    category:
        - blog
        - Work
    tag:
        - Docker
        - Golang
header_image_file: 'https://ws1.sinaimg.cn/mw1024/e724cbefgy1fdcdnvrddtj218g0nm1kx'
---

我，一个 Java 的忠粉，前些日子也不得不开始用 Golang 写一些东西，原因其实很简单，语言也好信仰也好，都敌不过一个基本实现需求的能够为我节省大量代码的开源软件。

一年之前第一次值班，被各种问题弄得焦头烂额，当时就想着要是有个系统，能把生产系统中正在发生的各种问题以告警的方式给出来，同时附带解决方案该多好。当时也是初生牛犊不怕虎，值班日报里随即把基于日志采集实现业务监控、可视化的方案说了一通，复用阿里云的各种基础设施，也许只要数天就能搭建一套完备的日志采集、存储、分析、可视化、告警体系。

于是实现这个方案就成了我的工作，但是有一个约束：为了实现依赖最小化，我必须使用团队内部提供的基础设施来实现，不能使用中间件那套虽然看起来完善但是底下不知道水多深的技术栈。

===

吭哧吭哧搞了一的多月，整合业界常见的大数据三板斧 Storm 和 Kafka，加上团队提供的 [HybridDB][1] 数仓，还有在生产代码里加上埋点，我也算是造了一套日志采集、存储、分析的轮子。但是这套系统我一直不好意思拿出去给同事们用，因为它太难用了。难用不难用和我用什么后端技术完全没关系，只和我用什么用户界面有关系。之前我在菜鸟的时候，基于 ODPS（现在叫 MaxCompute）做的日志查询和分析，虽然能实现很多功能，比如准实时生产日志查询、性能剖析、强弱依赖分析等等，但是因为获取这些信息的时候需要写 SQL，结果就是除了我之外没几个同事在用。

没有一个靠谱的用户界面一直是我这套日志系统的致命硬伤，但是业界之前似乎没有什么好的能够直接基于关系数据库做可视化的开源系统。直到后来我才知道 Airbnb 开源了一个 superset。其实我看一直都想要用上 Grafana，一个是因为它酷炫的界面，另一个则是它在 4.x 版本里新出的 Alert 功能。一旦能够用上 Grafana，那么我的日志系统就有了一个超级靠谱的可视化用户界面，和一个勉强可用的监控告警，整个功能就齐全了。

也许还真是我运气不错，让我在 Github 里找到一个数据源插件，这个插件能够让 Grafana 使用 MySQL 协议或者 PostgreSQL 协议从关系数据库中获取数据并展示出来，实现类似于 Influxdb 的效果。美中不足的是，这个插件不支持 Alert 功能，因为这个插件是在 3.x 下开发的，而 Alert 在 4.x 才有，也只有 Grafana 官方维护的数据源才同步支持了 Alert。

魔改开源软件，我也算是一把好手了。Grafana 经过本绅士的魔改之后，不仅支持 SQL 数据源，还给 SQL 数据源加上了 Alert 功能；不仅可以在 Alert 时发邮件，还能往钉钉群推消息；不仅能推消息，还能@指定的人，还能根据变量渲染告警消息；存放告警指标截图的图床，除了原生支持的 S3 和 WebDAV，我还给加上了阿里云 OSS；之前只能明文放在配置文件里的数据库和密码，被我加密存起来了……

经过我魔改的Grafana，不仅在我所在的小团队里迅速被几个业务采用，还以软件包的形式给输出其他团队，其中的杀手级特性，当属钉钉推送，这也算是我意料之中的~

托 Grafana 的福，我写了一星期的 Golang，也算是又多了一门上过生产环境的语言。除了 Golang，我还发现一些有趣的软件工程技巧和常见的设计缺陷，一并记录下来。

1. Golang 的错误处理真是麻烦得不行
   
   ```
   if out, err := json.Marshal(); err != nil {
       // handle error
   } else {
       // real code
   }
   ```
   
   Golang 迫使用户在几乎所有函数返回之后，立刻处理函数返回值中的错误信息。但是在我写过的有用的代码中，几乎所有深层代码，是没有能力去处理各种异常/错误的，只能把异常/错误原封不动交给上一层调用。在函数返回值中返回错误信息，不仅使得错误处理和业务逻辑耦合在一起，还让我们喜闻乐见的连续调用变的不可能。

   ```
   // other languages
   return f(g(x))
   // Golang
   if gg, err := g(x): err != nil {
       return nil, err
   } else {
       if ff, err := f(gg); err != nil {
          return nil, err
       } else {
           return ff, nil
       }
   }
   ```

   真是简洁优雅呢~

2. 在系统启动过程中自动执行数据库变更

   Grafana 有一套 Migration 代码，用来在系统启动并连接到数据库之后，自动执行诸如创建表结构、表结构升级之类的操作。也许是出于便于集中权限管理的原因，我从没在工作中见到有一个系统是这么做的，我们都需要在系统进入 stage 环境之前就把 DDL 提交到数据库管理平台上，由 DBA 审核之后才能在业务低峰期执行。也许这也和我一直以来的工作都是维护 SaaS  提供服务而不是输出软件有关系，但是这种做法在需要输出软件的时候真的很方便用户，无论是部署还是使用都很方便。

3. Docker build 阶段使用代理来加速网络

   在为开源软件做 Docker 镜像的时候，经常在 build 阶段耗费大量时间，就算把明面上需要下载的资源弄到了本地，还是会在一些看不到的地方访问一些不存在的网站，比如 npm install 的时候，即使把仓库指向了墙内镜像，也还是招架不住某些软件包在 install.js 里去 Github 下东西，然后 Github 的资源又是托管在 S3 上的，除非在打包的时候开个 VPN 全局代理，否则 build 过程卡个半个多一个小时没结果是常有的事情。

   幸好 Docker build 有一个 `--build-args` 参数，可以在 build 阶段设置一些环境变量，比如 `docker build --build-args HTTPS_PROXY=127.0.0.1:8888 nobody/awesome-image .`，就可以在构建镜像的时候指定一个 https 协议代理。需要注意的是 mac OS 上的 Docker 是运行在一个虚拟机里的，127.0.0.1 指向的是虚拟机而不是宿主机，所以在 mac OS 上使用这个黑科技的时候，要把 IP 改成宿主机的 IP。

4. 超时控制

   超时（Timeout）是每个在线系统需要在意的事情，只要是可以遇见到会有较长耗时的阻塞调用，就得考虑如果在可接受的时间内无法拿到结果该如何处理；如果一次请求内有多个可能阻塞的调用， 还需要根据这些调用的重要程度和预期的请求耗时，安排合理的超时配置。Grafana 的 Alert 特性在这一点上做得比较糟糕。

   

[1]: https://www.aliyun.com/product/gpdb
